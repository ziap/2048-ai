class KeyboardInputManager{constructor(){this.events={},window.navigator.msPointerEnabled?(this.eventTouchstart="MSPointerDown",this.eventTouchmove="MSPointerMove",this.eventTouchend="MSPointerUp"):(this.eventTouchstart="touchstart",this.eventTouchmove="touchmove",this.eventTouchend="touchend"),this.listen()}on(a,b){this.events[a]||(this.events[a]=[]),this.events[a].push(b)}emit(a,b){const c=this.events[a];c&&c.forEach(a=>{a(b)})}listen(){const a=this,b={38:0,39:1,40:2,37:3,75:0,76:1,74:2,72:3,87:0,68:1,83:2,65:3};document.addEventListener("keydown",c=>{const d=c.altKey||c.ctrlKey||c.metaKey||c.shiftKey,e=b[c.which];d||e===void 0||(c.preventDefault(),a.emit("move",e)),d||82!==c.which||a.restart.call(a,c)}),this.bindButtonPress(".retry-button",this.restart),this.bindButtonPress(".restart-button",this.restart),this.bindButtonPress(".keep-playing-button",this.keepPlaying);let c,d;const e=document.getElementsByClassName("game-container")[0];e.addEventListener(this.eventTouchstart,a=>{!window.navigator.msPointerEnabled&&1<a.touches.length||1<a.targetTouches.length||(window.navigator.msPointerEnabled?(c=a.pageX,d=a.pageY):(c=a.touches[0].clientX,d=a.touches[0].clientY),a.preventDefault())}),e.addEventListener(this.eventTouchmove,a=>{a.preventDefault()}),e.addEventListener(this.eventTouchend,b=>{if(!window.navigator.msPointerEnabled&&0<b.touches.length||0<b.targetTouches.length)return;let e,f;window.navigator.msPointerEnabled?(e=b.pageX,f=b.pageY):(e=b.changedTouches[0].clientX,f=b.changedTouches[0].clientY);const g=e-c,h=Math.abs(g),i=f-d,j=Math.abs(i);10<Math.max(h,j)&&a.emit("move",h>j?0<g?1:3:0<i?2:0)})}restart(a){a.preventDefault(),this.emit("restart")}keepPlaying(a){a.preventDefault(),this.emit("keepPlaying")}bindButtonPress(a,b){const c=document.querySelector(a);c.addEventListener("click",b.bind(this)),c.addEventListener(this.eventTouchend,b.bind(this))}}class HTMLActuator{constructor(){this.tileContainer=document.querySelector(".tile-container"),this.scoreContainer=document.querySelector(".score-container"),this.bestContainer=document.querySelector(".best-container"),this.messageContainer=document.querySelector(".game-message"),this.score=0}actuate({cells:a},b){const c=this;window.requestAnimationFrame(()=>{c.clearContainer(c.tileContainer),a.forEach(a=>{a.forEach(a=>{a&&c.addTile(a)})}),c.updateScore(b.score),c.updateBestScore(b.bestScore),b.terminated&&(b.over?c.message(!1):b.won&&c.message(!0))})}continueGame(){this.clearMessage()}clearContainer(a){for(;a.firstChild;)a.removeChild(a.firstChild)}addTile(a){const b=this,c=document.createElement("div"),d=document.createElement("div"),e=a.previousPosition||{x:a.x,y:a.y},f=this.positionClass(e),g=["tile",`tile-${a.value}`,f];2048<a.value&&g.push("tile-super"),this.applyClasses(c,g),d.classList.add("tile-inner"),d.textContent=a.value,a.previousPosition?window.requestAnimationFrame(()=>{g[2]=b.positionClass({x:a.x,y:a.y}),b.applyClasses(c,g)}):a.mergedFrom?(g.push("tile-merged"),this.applyClasses(c,g),a.mergedFrom.forEach(a=>{b.addTile(a)})):(g.push("tile-new"),this.applyClasses(c,g)),c.appendChild(d),this.tileContainer.appendChild(c)}applyClasses(a,b){a.setAttribute("class",b.join(" "))}normalizePosition({x:a,y:b}){return{x:a+1,y:b+1}}positionClass(a){return a=this.normalizePosition(a),`tile-position-${a.x}-${a.y}`}updateScore(a){this.clearContainer(this.scoreContainer);const b=a-this.score;if(this.score=a,this.scoreContainer.textContent=this.score,0<b){const a=document.createElement("div");a.classList.add("score-addition"),a.textContent=`+${b}`,this.scoreContainer.appendChild(a)}}updateBestScore(a){this.bestContainer.textContent=a}message(a){const b=a?"game-won":"game-over",c=a?"You win!":"Game over!";this.messageContainer.classList.add(b),this.messageContainer.getElementsByTagName("p")[0].textContent=c}clearMessage(){this.messageContainer.classList.remove("game-won"),this.messageContainer.classList.remove("game-over")}}class Grid{constructor(a,b){this.size=a,this.cells=b?this.fromState(b):this.empty()}empty(){const a=[];for(let b=0;b<this.size;b+=1){const c=a[b]=[];for(let a=0;a<this.size;a+=1)c.push(null)}return a}fromState(a){const b=[];for(let c=0;c<this.size;c+=1){const d=b[c]=[];for(let b=0;b<this.size;b+=1){const e=a[c][b];d.push(e?new Tile(e.position,e.value):null)}}return b}randomAvailableCell(){const a=this.availableCells();if(a.length)return a[Math.floor(Math.random()*a.length)]}availableCells(){const a=[];return this.eachCell((b,c,d)=>{d||a.push({x:b,y:c})}),a}eachCell(a){for(let b=0;b<this.size;b+=1)for(let c=0;c<this.size;c+=1)a(b,c,this.cells[b][c])}cellsAvailable(){return!!this.availableCells().length}cellAvailable(a){return!this.cellOccupied(a)}cellOccupied(a){return!!this.cellContent(a)}cellContent(a){return this.withinBounds(a)?this.cells[a.x][a.y]:null}insertTile(a){this.cells[a.x][a.y]=a}removeTile({x:a,y:b}){this.cells[a][b]=null}withinBounds({x:a,y:b}){return 0<=a&&a<this.size&&0<=b&&b<this.size}serialize(){const a=[];for(let b=0;b<this.size;b+=1){const c=a[b]=[];for(let a=0;a<this.size;a+=1)c.push(this.cells[b][a]?this.cells[b][a].serialize():null)}return{size:this.size,cells:a}}}class Tile{constructor({x:a,y:b},c){this.x=a,this.y=b,this.value=c||2,this.previousPosition=null,this.mergedFrom=null}savePosition(){this.previousPosition={x:this.x,y:this.y}}updatePosition({x:a,y:b}){this.x=a,this.y=b}serialize(){return{position:{x:this.x,y:this.y},value:this.value}}}window.fakeStorage={_data:{},setItem(a,b){return this._data[a]=b+""},getItem(a){return this._data.hasOwnProperty(a)?this._data[a]:void 0},removeItem(a){return delete this._data[a]},clear(){return this._data={}}};class LocalStorageManager{constructor(){this.bestScoreKey="bestScore",this.gameStateKey="gameState";const a=this.localStorageSupported();this.storage=a?window.localStorage:window.fakeStorage}localStorageSupported(){const a="test";try{const b=window.localStorage;return b.setItem(a,"1"),b.removeItem(a),!0}catch(a){return!1}}getBestScore(){return this.storage.getItem(this.bestScoreKey)||0}setBestScore(a){this.storage.setItem(this.bestScoreKey,a)}getGameState(){const a=this.storage.getItem(this.gameStateKey);return a?JSON.parse(a):null}setGameState(a){this.storage.setItem(this.gameStateKey,JSON.stringify(a))}clearGameState(){this.storage.removeItem(this.gameStateKey)}}export class GameManager{constructor(a){this.size=a,this.inputManager=new KeyboardInputManager,this.storageManager=new LocalStorageManager,this.actuator=new HTMLActuator,this.startTiles=2,this.inputManager.on("move",this.move.bind(this)),this.inputManager.on("restart",this.restart.bind(this)),this.inputManager.on("keepPlaying",this.keepPlaying.bind(this)),this.setup()}restart(){this.storageManager.clearGameState(),this.actuator.continueGame(),this.setup()}keepPlaying(){this.keepPlaying=!0,this.actuator.continueGame()}isGameTerminated(){return this.over||this.won&&!this.keepPlaying}setup(){const a=this.storageManager.getGameState();a?(this.grid=new Grid(a.grid.size,a.grid.cells),this.score=a.score,this.over=a.over,this.won=a.won,this.keepPlaying=a.keepPlaying):(this.grid=new Grid(this.size),this.score=0,this.over=!1,this.won=!1,this.keepPlaying=!1,this.addStartTiles()),this.actuate()}addStartTiles(){for(let a=0;a<this.startTiles;a+=1)this.addRandomTile()}addRandomTile(){if(this.grid.cellsAvailable()){const a=.9>Math.random()?2:4,b=new Tile(this.grid.randomAvailableCell(),a);this.grid.insertTile(b)}}actuate(){this.storageManager.getBestScore()<this.score&&this.storageManager.setBestScore(this.score),this.over?this.storageManager.clearGameState():this.storageManager.setGameState(this.serialize()),this.actuator.actuate(this.grid,{score:this.score,over:this.over,won:this.won,bestScore:this.storageManager.getBestScore(),terminated:this.isGameTerminated()})}serialize(){return{grid:this.grid.serialize(),score:this.score,over:this.over,won:this.won,keepPlaying:this.keepPlaying}}prepareTiles(){this.grid.eachCell((a,b,c)=>{c&&(c.mergedFrom=null,c.savePosition())})}moveTile(a,b){this.grid.cells[a.x][a.y]=null,this.grid.cells[b.x][b.y]=a,a.updatePosition(b)}move(a){const b=this;if(this.isGameTerminated())return;let c,d;const e=this.getVector(a),f=this.buildTraversals(e);let g=!1;this.prepareTiles(),f.x.forEach(a=>{f.y.forEach(f=>{if(c={x:a,y:f},d=b.grid.cellContent(c),d){const a=b.findFarthestPosition(c,e),f=b.grid.cellContent(a.next);if(f&&f.value===d.value&&!f.mergedFrom){const c=new Tile(a.next,2*d.value);c.mergedFrom=[d,f],b.grid.insertTile(c),b.grid.removeTile(d),d.updatePosition(a.next),b.score+=c.value,65536===c.value&&(b.won=!0)}else b.moveTile(d,a.farthest);b.positionsEqual(c,d)||(g=!0)}})}),g&&(this.addRandomTile(),!this.movesAvailable()&&(this.over=!0),this.actuate())}getVector(a){return{0:{x:0,y:-1},1:{x:1,y:0},2:{x:0,y:1},3:{x:-1,y:0}}[a]}buildTraversals({x:a,y:b}){const c={x:[],y:[]};for(let d=0;d<this.size;d+=1)c.x.push(d),c.y.push(d);return 1===a&&(c.x=c.x.reverse()),1===b&&(c.y=c.y.reverse()),c}findFarthestPosition(a,{x:b,y:c}){let d;do d=a,a={x:d.x+b,y:d.y+c};while(this.grid.withinBounds(a)&&this.grid.cellAvailable(a));return{farthest:d,next:a}}movesAvailable(){return this.grid.cellsAvailable()||this.tileMatchesAvailable()}tileMatchesAvailable(){const a=this;let b;for(let c=0;c<this.size;c+=1)for(let d=0;d<this.size;d+=1)if(b=this.grid.cellContent({x:c,y:d}),b)for(let e=0;4>e;e+=1){const f=a.getVector(e),g={x:c+f.x,y:d+f.y},h=a.grid.cellContent(g);if(h&&h.value===b.value)return!0}return!1}positionsEqual(a,b){return a.x===b.x&&a.y===b.y}}
